(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{465:function(a,t,s){"use strict";s.r(t);var r=s(25),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"q-1-0-cpu-内部是由什么组成的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-1-0-cpu-内部是由什么组成的？"}},[a._v("#")]),a._v(" Q:1.0 CPU 内部是由什么组成的？")]),a._v(" "),s("p",[a._v("A: CPU 主要由运算器，控制器，寄存器三部分组成。三者之间依靠内部总线相联系（之前提到的总线是外部总线）。其中运算器是做信息处理的，寄存器是做信息存储，控制器则是控制器件工作，内部总线是连接了各种元器件，进行数据传送。")]),a._v(" "),s("p",[a._v("其中寄存器最为重要，我们可以通过改变寄存器的内容来实现对 CPU 的控制。寄存器有很多，8086CPU 里面由 14 个寄存器。")]),a._v(" "),s("h1",{attrs:{id:"q-寄存器内部原理是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-寄存器内部原理是什么？"}},[a._v("#")]),a._v(" Q:寄存器内部原理是什么？")]),a._v(" "),s("p",[a._v("A: 8086CPU 的寄存器是 16 位的，其中 AX，BX，CX，DX用来存放一般性数据被称为通用寄存器。其中 AX 里面是16位，也就是可以储存16位的数据，但是之前的寄存器是 8位的为了保证和上一代的兼容，16位的可以拆分成两个 8位的，即 AX = AH + AL，可以分成两个寄存器。")]),a._v(" "),s("h1",{attrs:{id:"q-寄存器是如何存储信息的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-寄存器是如何存储信息的？"}},[a._v("#")]),a._v(" Q:寄存器是如何存储信息的？")]),a._v(" "),s("p",[a._v("A: 1 字节等于 8 比特，1 字节可以存在 8 位的寄存器中，而字是由两个字节组成，分为高字节和低字节可以储存在 16 位的寄存器中。")]),a._v(" "),s("h1",{attrs:{id:"q-介绍几个汇编指令吧？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-介绍几个汇编指令吧？"}},[a._v("#")]),a._v(" Q: 介绍几个汇编指令吧？")]),a._v(" "),s("p",[a._v("A:\nmov ax,18 指将 18 赋值给变量 ax\nadd ax,8 指变量 ax 加上 18")]),a._v(" "),s("h1",{attrs:{id:"q-物理地址是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-物理地址是什么？"}},[a._v("#")]),a._v(" Q:物理地址是什么？")]),a._v(" "),s("p",[a._v("A: 物理地址就是内存地址，每一个内存单元都由唯一的地址，CPU 首先需要在内部产生一个数字，然后再地址总线上表示出来。")]),a._v(" "),s("h1",{attrs:{id:"q-16位到底指什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-16位到底指什么？"}},[a._v("#")]),a._v(" Q:16位到底指什么？")]),a._v(" "),s("p",[a._v("A: 8086CPU是16位的，而之前的机器是 8 位的，16 位表示计算机一次可处理的数据最长为 16 位，具体到 CPU 上就是运算器一次可处理 16 位数据，寄存器的最大宽度是 16 位，寄存器和运算器之间的通路也是 16 位。")]),a._v(" "),s("h1",{attrs:{id:"q-cpu如如何给出物理地址的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-cpu如如何给出物理地址的？"}},[a._v("#")]),a._v(" Q:CPU如如何给出物理地址的？")]),a._v(" "),s("p",[a._v("A:以 8086CPU 为例，其寄存器是 16 位的所以一次只能表示 16 位的数字，但是它的地址总线的宽度是 20 位的，所以需要两个寄存器合起来表示。两个寄存器表示出来的数据通过地址加法器来合成，然后输入到控制电路中推送到地址总线上。")]),a._v(" "),s("h1",{attrs:{id:"q-地址加法器是工作的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-地址加法器是工作的？"}},[a._v("#")]),a._v(" Q:地址加法器是工作的？")]),a._v(" "),s("p",[a._v("A:地址加法器可以将输入分为段地址和偏移地址，而输出则是物理地址，其中 段地址×16 + 偏移地址 = 物理地址。")]),a._v(" "),s("h1",{attrs:{id:"q-段地址为什么要乘-16-？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-段地址为什么要乘-16-？"}},[a._v("#")]),a._v(" Q: 段地址为什么要乘 16 ？")]),a._v(" "),s("p",[a._v("A:因为寄存器是16位的，乘 16 后相当于左移 4 位，留出来 4 个位置供偏移地址补上。加上后就变成了 20 位，就能放入地址总线中了。")]),a._v(" "),s("h1",{attrs:{id:"q-什么是段？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-什么是段？"}},[a._v("#")]),a._v(" Q: 什么是段？")]),a._v(" "),s("p",[a._v("A: CPU内部并没有将内存地址划分成段，而是根据段地址和偏移地址来划分的，段地址乘 16 ，所以段的开头是 16 的倍数，而偏移地址是 16 位，所以寻址能力位 64kb，即段长位 64kb .")]),a._v(" "),s("h1",{attrs:{id:"q-那段地址-cpu-是怎么提供的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-那段地址-cpu-是怎么提供的？"}},[a._v("#")]),a._v(" Q: 那段地址 CPU 是怎么提供的？")]),a._v(" "),s("p",[a._v("A:在CPU 的内部由专门的段寄存器，例如 8086CPU 内部由 CS/DS/SS/ES 四个段寄存器来提供内存单元的段地址。")])])}),[],!1,null,null,null);t.default=v.exports}}]);